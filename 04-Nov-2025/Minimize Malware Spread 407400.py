# Problem: Minimize Malware Spread - https://leetcode.com/problems/minimize-malware-spread/

class uf:
    def __init__(self, n):
        self.par = [i for i in range(n)]
        self.size = [1] * n

    def find(self, node):
        while node != self.par[node]:
            self.par[node] = self.par[self.par[node]]
            node = self.par[node]
        return self.par[node]
    
    def union(self, u, v):
        par_u = self.find(u)
        par_v = self.find(v)

        if par_u == par_v:
            return False
        if self.size[par_u] < self.size[par_v]:
            par_u, par_v = par_v, par_u
        
        self.par[par_v] = par_u
        self.size[par_u] += self.size[par_v]
        return True

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        uniFind = uf(n)
        
       
        for i in range(n):
            for j in range(i + 1, n):
                if graph[i][j] == 1:
                    uniFind.union(i, j)
        
     
        infected_count = defaultdict(int)
        for node in initial:
            par = uniFind.find(node)
            infected_count[par] += 1
        
       
        initial.sort()
        
        best_node = initial[0]
        max_saved = -1
        
        for node in initial:
            par = uniFind.find(node)
          
            if infected_count[par] == 1:
                saved = uniFind.size[par]
                if saved > max_saved:
                    max_saved = saved
                    best_node = node
        
        return best_node
